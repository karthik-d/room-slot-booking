from django.shortcuts import render
from django.views import View
from django.contrib import messages
from django.urls import reverse
from django.http import HttpResponseRedirect
from django.contrib.auth import authenticate
from django.contrib.auth.decorators import login_required
from django.utils.decorators import method_decorator
from roomBookingManager.decorators import group_required, anonymous_required
from .forms import EmployeeIDGeneration
from users.models import Admin, EmployeeID
from users.constants import EMPLOYEE_PREFIXES
from customer_iface.utilities import send_generated_key


@method_decorator(group_required('AdminPrivilege',redirect_view='Login'), name='dispatch')
class GenerateEmployeeID(View):
	form = EmployeeIDGeneration()
	template = 'admin_iface/DisplayForm.html'
	
	def verify_password(self,request,pwd):
		user_email = request.user.email		
		if(authenticate(request,email=user_email,password=pwd)):
			return True
		else:
			return False	
	
	def post(self,request,*args,**kwargs):
		self.form = EmployeeIDGeneration(request.POST)
		
		try:
			if(self.form.is_valid()):
				if(self.verify_password(request,self.form.cleaned_data['password'])):
				
					emp_typ = self.form.cleaned_data['designation']
					pre = EMPLOYEE_PREFIXES[emp_typ]
					serial = pre+(str(EmployeeID.objects.filter(emp_type=emp_typ).count()+1).rjust(3,'0'))
					this_admin = Admin.objects.filter(instance__email=request.user.email)[0]
					this_user = this_admin.instance
					
					new_empid = EmployeeID(emp_id=serial, emp_type=emp_typ, creator=this_user)
					new_empid.save()
					
					send_generated_key(new_empid)
					messages.add_message(request, messages.SUCCESS, "Employee ID Generated - "+serial+". Attempted to send email")
					return HttpResponseRedirect(reverse('GenerateID'))
					
				else:
					raise ValueError("Incorrect Password!\nAuthentication Failed")
					
			else:
				raise ValueError("Invalid Form")	
					
		except ValueError as prob:
			messages.add_message(request, messages.ERROR, prob)
			return HttpResponseRedirect(reverse('GenerateID'))	
				
		except KeyError:
			messages.add_message(request, message.ERROR, "Invalid Designation Entered")
			return HttpResponseRedirect(reverse('GenerateID'))		
				
	
	def get(self,request,*args,**kwargs):
		cont = dict()
		cont['form'] = self.form
		cont['prompt'] = "Create New Employee"
		return render(request, self.template, context=cont)


@method_decorator(group_required('AdminPrivilege',redirect_view='Login'), name='dispatch')		
class ManageEmployeeID(View):
	""" Class based view to see and manage all employee IDs generated by 
	all the admins
	"""	
	
	template = "admin_iface/ViewIds.html"	
	
	def post(self, request):
		# Performing deletion operation
		target_empid = request.POST['empId']
		target_empid_inst = EmployeeID.objects.get(emp_id=target_empid)
		target_empid_inst.assignee.delete() # Deleteing the user/employee
		target_empid_inst.assignee = None   # Freeing the employee ID instance
		messages.add_message(request, messages.SUCCESS, "Employee Deleted Successfully. This employee ID can be assigned to a new employee of same type")
		# The associated reservations, rooms, etc are automatically cascaded
		# The isolated res data is updated using signals attached to Reservation model
		return HttpResponseRedirect(reverse('home'))
	
	def get(self, request):	
		usable_ids = EmployeeID.objects.filter(assignee=None).exclude(creator=None)  #EXCLUDE BASE_ADMIN
		admin_links = [(i.creator.name,                 
						i.creator.email) for i in usable_ids]				
		data_ids = [(usable_ids[i].emp_id,
                     usable_ids[i].emp_type) for i in range(len(usable_ids))]
		usable_ids = list(zip(admin_links,data_ids))             
                   
		used_ids = EmployeeID.objects.all().exclude(assignee=None).exclude(creator=None)  #EXCLUDE BASE_ADMIN
		form_row = [('a'+str(x+1),'b'+str(x+1)) for x in range(len(used_ids))]
		emp_links = [(i.assignee.name,                 
						i.assignee.email) for i in used_ids]
		admin_links = [(i.creator.name,                 
						i.creator.email) for i in used_ids]	
		data_ids = [(used_ids[i].emp_id,
                     used_ids[i].emp_type) for i in range(len(used_ids))]
		used_ids = list(zip(emp_links,admin_links,form_row,data_ids))           
                     
		cont = dict()   
		cont['usableIds'] = usable_ids
		cont['usedIds'] = used_ids
		cont['display'] = (bool(len(usable_ids)),bool(len(used_ids)))
        
		return render(request,self.template,context=cont) 	
		
